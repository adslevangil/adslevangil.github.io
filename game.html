<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <title>小游戏</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #333;
    }
    /* 游戏容器保持 600×600 像素 */
    #container {
      position: relative;
      width: 600px;
      height: 600px;
      background-color: #000;
      overflow: hidden;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: #222;
      color: #fff;
      font-family: sans-serif;
    }
    #gameCanvas {
      display: none;
      background-color: #000;
    }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      background-color: rgba(0,0,0,0.6);
      color: #fff;
      font-family: sans-serif;
      text-align: center;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
    #timer {
      position: absolute;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 20px;
      font-family: sans-serif;
      display: none;
    }
    /* 自定义关闭按钮 */
    #closeBtn {
      position: absolute;
      top: 5px;
      right: 5px;
      color: #fff;
      cursor: pointer;
      font-size: 20px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="container">
    <span id="closeBtn" onclick="closeGame()">×</span>
    <div id="menu">
      <h1>欢迎来到小游戏</h1>
      <button onclick="startGame()">开始游戏</button>
      <button onclick="closeGame()">退出</button>
    </div>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <div id="timer"></div>
    <div id="overlay">
      <h1 id="resultMessage"></h1>
      <button id="restartBtn" onclick="restartGame()" style="display:none;">重新开始</button>
      <div id="successNote" style="font-size:14px;margin-top:20px;display:none;">点击任意位置返回主菜单</div>
    </div>
  </div>
<script>
  // 游戏相关变量
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const menu = document.getElementById('menu');
  const overlay = document.getElementById('overlay');
  const timerElement = document.getElementById('timer');
  const resultMessage = document.getElementById('resultMessage');
  const restartBtn = document.getElementById('restartBtn');
  const successNote = document.getElementById('successNote');
  const container = document.getElementById('container');

  let player = { x: 290, y: 290, size: 20, speed: 4, tx: 290, ty: 290 };
  let bullets = [];
  let keys = {};
  let countdown = 30; // 倒计时秒数
  let gameInterval = null;
  let running = false; // 控制动画循环是否继续
  let spawnInterval = null;
  let spawnIntervalTime = 500; // 子弹初始产生间隔（毫秒）
  let densityInterval = null;  // 用于定期增加密度的计时器
  let timerInterval = null;
  let gameState = 'menu'; // menu / playing / success / fail

  // 用于碰撞后碎裂效果的粒子
  let fragments = [];

  // 监听键盘
  document.addEventListener('keydown', (e) => { keys[e.keyCode] = true; });
  document.addEventListener('keyup', (e) => { keys[e.keyCode] = false; });

  // 鼠标点击移动玩家方块到点击位置
  canvas.addEventListener('click', function(e) {
    if (gameState !== 'playing') return;
    const rect = canvas.getBoundingClientRect();
    // 计算相对于 canvas 的点击位置
    let clickX = e.clientX - rect.left;
    let clickY = e.clientY - rect.top;
    // 设定目标点为点击位置的中心
    let tx = clickX - player.size / 2;
    let ty = clickY - player.size / 2;
    // 边界限制目标点
    if (tx < 0) tx = 0;
    if (tx > canvas.width - player.size) tx = canvas.width - player.size;
    if (ty < 0) ty = 0;
    if (ty > canvas.height - player.size) ty = canvas.height - player.size;
    player.tx = tx;
    player.ty = ty;
  });

  function startGame() {
    menu.style.display = 'none';
    canvas.style.display = 'block';
    timerElement.style.display = 'block';
    overlay.style.display = 'none';
    gameState = 'playing';
    player.x = 290; player.y = 290;
    bullets = [];
    fragments = [];
    spawnIntervalTime = 500;
    countdown = 30;
    // 初始化目标点为当前玩家位置
    player.tx = player.x;
    player.ty = player.y;
    timerElement.textContent = String(countdown);
    timerInterval = setInterval(() => {
      countdown--;
      timerElement.textContent = String(countdown);
      if (countdown <= 0) {
        endGame('success');
      }
    }, 1000);
    // 设置生成子弹的定时器并启动密度提升计时器
    spawnInterval = setInterval(spawnBullet, spawnIntervalTime);
    densityInterval = setInterval(increaseDensity, 3000);
    // 启动动画循环
    running = true;
    requestAnimationFrame(gameLoop);
  }

  function closeGame() {
    // 尝试关闭窗口，如果浏览器禁止关闭，则跳转空白页
    if (window.close) {
      window.close();
    }
    location.href = 'about:blank';
  }

  function endGame(state) {
    gameState = state;
    clearInterval(spawnInterval);
    clearInterval(densityInterval);
    clearInterval(timerInterval);
    // 结束时取消动画帧循环，防止累积加速
    if (gameInterval) {
      cancelAnimationFrame(gameInterval);
      gameInterval = null;
    }
    // 标记不再继续动画帧循环
    running = false;
    overlay.style.display = 'flex';
    resultMessage.textContent = (state === 'success') ? '游戏成功通关！' : '游戏失败！';
    restartBtn.style.display = (state === 'fail') ? 'inline-block' : 'none';
    successNote.style.display = (state === 'success') ? 'block' : 'none';
    if (state === 'success') {
      container.addEventListener('click', returnToMenuOnce);
    }
  }

  function returnToMenuOnce() {
    container.removeEventListener('click', returnToMenuOnce);
    returnToMenu();
  }

  function returnToMenu() {
    overlay.style.display = 'none';
    canvas.style.display = 'none';
    timerElement.style.display = 'none';
    menu.style.display = 'flex';
  }

  function restartGame() {
    overlay.style.display = 'none';
    canvas.style.display = 'block';
    timerElement.style.display = 'block';
    bullets = [];
    fragments = [];
    spawnIntervalTime = 500;
    player.x = 290;
    player.y = 290;
    // 初始化目标点为当前玩家位置
    player.tx = player.x;
    player.ty = player.y;
    countdown = 30;
    timerElement.textContent = String(countdown);
    timerInterval = setInterval(() => {
      countdown--;
      timerElement.textContent = String(countdown);
      if (countdown <= 0) {
        endGame('success');
      }
    }, 1000);
    spawnInterval = setInterval(spawnBullet, spawnIntervalTime);
    densityInterval = setInterval(increaseDensity, 3000);
    gameState = 'playing';
    // 启动动画循环
    running = true;
    requestAnimationFrame(gameLoop);
  }

  // 每 3 秒降低子弹间隔（增加密度）
  function increaseDensity() {
    // 减少间隔 20%
    spawnIntervalTime = spawnIntervalTime * 0.8;
    clearInterval(spawnInterval);
    spawnInterval = setInterval(spawnBullet, spawnIntervalTime);
  }

  function spawnBullet() {
    if (gameState !== 'playing') return;
    const side = Math.floor(Math.random() * 4);
    let x, y, targetX, targetY;
    const speed = 3;
    switch (side) {
      case 0: // 左侧
        x = -2; y = Math.random() * canvas.height;
        targetX = canvas.width + 2; targetY = Math.random() * canvas.height;
        break;
      case 1: // 右侧
        x = canvas.width + 2; y = Math.random() * canvas.height;
        targetX = -2; targetY = Math.random() * canvas.height;
        break;
      case 2: // 上方
        x = Math.random() * canvas.width; y = -2;
        targetX = Math.random() * canvas.width; targetY = canvas.height + 2;
        break;
      default: // 下方
        x = Math.random() * canvas.width; y = canvas.height + 2;
        targetX = Math.random() * canvas.width; targetY = -2;
        break;
    }
    const dx = targetX - x;
    const dy = targetY - y;
    const len = Math.sqrt(dx * dx + dy * dy);
    const vx = dx / len * speed;
    const vy = dy / len * speed;
    // 子弹大小增加一倍，改为 4×4 像素
    bullets.push({ x: x, y: y, vx: vx, vy: vy, size: 4 });
  }

  function updatePlayer() {
    // 按一定速度向目标点移动
    // 计算到目标点的向量
    const dx = player.tx - player.x;
    const dy = player.ty - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > player.speed) {
      // 按比例移动到下一位置
      player.x += (dx / dist) * player.speed;
      player.y += (dy / dist) * player.speed;
    } else {
      // 距离小于速度时直接停到目标
      player.x = player.tx;
      player.y = player.ty;
    }
    // 边界限制当前方块位置
    if (player.x < 0) player.x = 0;
    if (player.x > canvas.width - player.size) player.x = canvas.width - player.size;
    if (player.y < 0) player.y = 0;
    if (player.y > canvas.height - player.size) player.y = canvas.height - player.size;
  }

  function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.vx;
      b.y += b.vy;
      // 如果子弹离开视图则删除
      if (b.x < -10 || b.x > canvas.width + 10 || b.y < -10 || b.y > canvas.height + 10) {
        bullets.splice(i, 1);
      }
    }
  }

  function checkCollisions() {
    for (let i = 0; i < bullets.length; i++) {
      const b = bullets[i];
      if (b.x + b.size > player.x && b.x < player.x + player.size &&
          b.y + b.size > player.y && b.y < player.y + player.size) {
        // 碰撞发生，创建碎裂效果
        createFragments(b.x + b.size / 2, b.y + b.size / 2);
        // 停止定时器，进入碎裂动画阶段
        gameState = 'fragment';
        clearInterval(spawnInterval);
        clearInterval(densityInterval);
        clearInterval(timerInterval);
        // 删除当前子弹，使其不再绘制
        bullets.splice(i, 1);
        // 在碎裂动画一段时间后再结束游戏
        setTimeout(() => { endGame('fail'); }, 500);
        return;
      }
    }
  }

  // 创建碎裂粒子
  function createFragments(cx, cy) {
    fragments = [];
    const count = 12;
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 2 + Math.random() * 2; // 2–4 像素/帧
      fragments.push({
        x: cx,
        y: cy,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 20
      });
    }
  }

  // 更新碎裂粒子
  function updateFragments() {
    for (let i = fragments.length - 1; i >= 0; i--) {
      const f = fragments[i];
      f.x += f.vx;
      f.y += f.vy;
      f.life--;
      // 简单的阻尼效果让碎片逐渐减速
      f.vx *= 0.9;
      f.vy *= 0.9;
      if (f.life <= 0) {
        fragments.splice(i, 1);
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制玩家方块
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(player.x, player.y, player.size, player.size);
    // 绘制子弹
    ctx.fillStyle = '#FF0000';
    for (let i = 0; i < bullets.length; i++) {
      const b = bullets[i];
      ctx.fillRect(b.x, b.y, b.size, b.size);
    }
    // 绘制碎裂粒子
    if (fragments.length > 0) {
      ctx.fillStyle = '#FFEE00';
      for (let i = 0; i < fragments.length; i++) {
        const f = fragments[i];
        ctx.fillRect(f.x, f.y, 2, 2);
      }
    }
  }

  function gameLoop() {
    // 在不同阶段执行不同更新
    if (gameState === 'playing') {
      updatePlayer();
      updateBullets();
      checkCollisions();
    } else if (gameState === 'fragment') {
      updateFragments();
    }
    // 始终绘制场景（包括碎片）
    draw();
    // 只有在运行状态下才继续请求动画帧，防止重启加速
    if (running) {
      requestAnimationFrame(gameLoop);
    }
  }
</script>
</body>
</html>